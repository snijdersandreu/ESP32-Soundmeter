<!DOCTYPE html>
<html>
<head>
<title>informe.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="projecte-grup-4-son%C3%B2metre">Projecte Grup 4: Sonòmetre</h1>
<p>Descripció general del projecte</p>
<p><br><hr></p>
<h1 id="1-sensor-lectura-dades-microcontrolador">1. Sensor, lectura dades microcontrolador</h1>
<p>definicio del que s'ha fet en aquest apartat. Explicar que utilitzarem el microcontrolador ESP32</p>
<h3 id="11-caracter%C3%ADstiques-del-sensor">1.1 Característiques del sensor</h3>
<p>El sensor que implementarem en el nostre projecte és un sensor de pressió sonora de la marca de components 'PCB Artists'. Les característiques principals d'aquest sensor són:</p>
<ul>
<li>Precisió de ±2 dB SPL</li>
<li>Rang de mesura de 35 dB a 115 dB</li>
<li>Rang de mesura de 30 Hz a 8 kHz</li>
<li>Comunicació amb protocol I2C (Adress = 0x48)</li>
<li>Alimentació 5mA @ 3.3V (measurement) and 100uA (sleep)</li>
<li>Es pot seleccionar ponderació de freqüències: A-weighted, C-weighted, Z-weighted</li>
<li>Temps de 'averaging' de la mesura ajustable 10ms to 10,000 ms</li>
<li>2 modes de mesura: 125ms (fast mode) i 1,000ms (slow mode)</li>
<li>Threshold detection and interrupt</li>
<li>100-reading buffer to allow host MCU to sleep
<br></li>
</ul>
<p>El sensor per defecte s'inicialitza amb la següent configuració:</p>
<ul>
<li>
<p><strong>Ponderació A:</strong> la utilitzada per determinar el soroll ambiental d'activitats. És la utilitzada pels diferents càlculs de nivell equivalent diurn i nocturn que es regulen a les ciutats.
<br></p>
</li>
<li>
<p><strong>1000 ms averaging duration</strong> (“slow mode” de sonòmetres comercials que trobem al mercat)
<br></p>
</li>
<li>
<p>Interrupt function <strong>disabled</strong>
<br></p>
</li>
<li>
<p><strong>L'historial de registres s'actualitza segons el 'averaging duration'</strong> (<strong>1000 ms</strong>) i es manté un registre de valor màxim i mínim.</p>
</li>
</ul>
<p>Aquesta configuració per defecte és la que utlitzarem en el nostre projecte.</p>
<br>
<p>La conexió amb el microcontrolador és la tipica en una conexió I2C. En el nostre microcontrolador ESP32 utilitzem els pins:</p>
<br>
<h3 id="12-comunicaci%C3%B3-amb-el-sensor">1.2 Comunicació amb el sensor:</h3>
<p>La comunicació entre el sensor i el microcontrolador es fa per mitjà d'un bus I2C. Es tracta d'una conexió sincrona que només requereix d'un bus de dos canals:</p>
<ul>
<li><strong>CLK</strong>: canal pel qual s'envia el senyal de rellotge per poder sincronitzar els dispositius que comunica.</li>
<li><strong>SDA</strong>: canal pel qual s'envia la informació que es transmet. Aquesta anirà anirà sincronitzada amb la senyal de rellotge.</li>
</ul>
<p>L'alimentació del sensor es realitza a través del pin de 3V3. Els canals del bus I2C es conecten a la ESP32 pels pins: <strong>GPIO22</strong> i <strong>GPIO21</strong></p>
<p><img src="ESP32-I2C-Pins.jpg" alt="ESP32 pinout"></p>
<br>
<h3 id="12-codi-de-prova-del-sensor">1.2 Codi de prova del sensor:</h3>
<p>Hem creat un codi de prova per comprovar el funcionament del sensor i la comunicació amb el microcontrolador.</p>
<p>Hem implementat dues llibreries:</p>
<pre class="hljs"><code><div>include &lt;Arduino.h&gt;
include &lt;Wire.h&gt; <span class="hljs-comment">//per la comunicació I2C amb el sensor</span>
</div></code></pre>
<br>
<p>Hem definit dos valors constants que utilitzarem en la comunicació I2C:</p>
<pre class="hljs"><code><div>define PCBARTISTS_DBM       <span class="hljs-number">0x48</span>
define I2C_REG_DECIBEL      <span class="hljs-number">0x0A</span>
</div></code></pre>
<br>
<p>Definim una funció que ens permet llegir un únic byte del dispositiu I2C:</p>
<pre class="hljs"><code><div><span class="hljs-function">byte <span class="hljs-title">reg_read</span><span class="hljs-params">(byte addr, byte reg)</span>
</span>{
  Wire.beginTransmission(addr);
  Wire.write(reg);
  Wire.endTransmission();
  Wire.requestFrom(addr, (<span class="hljs-keyword">uint8_t</span>)<span class="hljs-number">1</span>);
  byte data = Wire.read();
  <span class="hljs-keyword">return</span> data;
}
</div></code></pre>
<br>
<p>En el block 'setup' iniciem els objectes necessaris:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> 
</span>{
  Serial.begin(<span class="hljs-number">115200</span>);
  Wire.begin();
}
</div></code></pre>
<br>
<p>En el loop basicament llegim el registre de memoria del dispositiu I2C que es correspon amb el nivell de pressió sonora detectat (1 byte). Posteriorment es mostra aquest nivell pel serial monitor. Es repeteix aquest procés cada 2 segons:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> 
</span>{
  byte sound_level = reg_read(PCBARTISTS_DBM, I2C_REG_DECIBEL);
  Serial.print(<span class="hljs-string">"Sound Level (dB SPL) = "</span>);
  Serial.println(sound_level);
  delay(<span class="hljs-number">2000</span>);
}
</div></code></pre>
<br>
<h3 id="13-comprovaci%C3%B3-del-correcte-funcionament-del-sensor">1.3 Comprovació del correcte funcionament del sensor:</h3>
<br>
<h3 id="14-implementaci%C3%B3-en-el-codi-final-del-projecte">1.4 Implementació en el codi final del projecte:</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span>
</span>{
  ...
  byte SPL_dBA = reg_read(PCBARTISTS_DBM, I2C_REG_DECIBEL);
  PUT_request(client, SPL_dBA);
  ...
}
</div></code></pre>
<p><br><hr></p>
<h1 id="2-transmissio%CC%81-dades-al-sentilo">2. Transmissió dades al Sentilo</h1>
<p>definicio del que s'ha fet en aquest apartat</p>
<h3 id="21-subapartat">2.1 subapartat</h3>
<p>contingut subapartat</p>
<p><br><hr></p>
<h1 id="3-configuracio%CC%81-i-gestio%CC%81-de-la-presentacio%CC%81-dades-sentilo">3. Configuració i gestió de la presentació dades (Sentilo)</h1>
<p>definicio del que s'ha fet en aquest apartat</p>
<h3 id="31-subapartat">3.1 subapartat</h3>

</body>
</html>
